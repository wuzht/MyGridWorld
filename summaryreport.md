# 中级实训总结报告

> 姓名：伍正涛
>
> 学号：16340246
>
> 班别：16级软件工程教务3班



[TOC]

> **实训简介（引用）**
>
> GridWorld案例提供了一个图形化环境用于可视化对象在二维网格中的交互。在这个案例中，你将设计和制造各种Actor的对象，将它们添加到一个网格中，并且根据一定的规则决定Actor的行为。此外我们还增加了三个扩展任务，ImageReader、N-Puzzle（华容道）和MazeBug（迷宫）。ImageReader实验要求参训学生利用本实验软装置，实现一个利用二进制流读取Bitmap图像，并且能够进行简单地处理和保存的软件；N-Puzzle实验要求参训学生利用广度优先搜索算法和启发式搜索算法完成重拼图游戏；MazeBug实验要参训学生采用深度优先搜索算法就可以走出迷宫。此项目要求参训学生在短时间内自学新的程序设计语言和相关工具，可以训练参训学生的快速学习的能力。通过此项目实训能让参训学生掌握在**Linux环境下进行代码编写、程序调试和测试**的基本知识，并且掌握使用JDK进行**Java程序设计，用Ant进行程序编译，部署和测试**，以及掌握**单元测试**的基本知识，能使用**JUnit编写测试用例**。另外，通过学习使用**Sonar来规范自己的代码风格，找出代码中潜在的bug**，让自己能写出良好的代码。同时扩展任务可以锻炼参训学生**图像处理能力**和学习、理解、应用**深度优先搜索算法**，**广度优先搜索算法**的能力。



## 阶段1：项目启动

本阶段主要是为实训项目做基本的技术准备，学会使用**Vi**, **JAVA**, **Ant** 和 **Junit**, 以及熟悉GridWorld的使用，并完成指定的任务。

### Java小程序

Java是一门面向对象的编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。

Java语言的应用极其广泛，使用人数极多，影响力不俗。在学习Java时，我了解到，Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等。Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点。

其实在大一的时候接触过Java了，不过那时候也只是学了那么一点点东西。到了这个学期实训之前，因为选上了两门课涉及C#的课程，现在来打Java，觉得Java和C#有惊人的相似（当然和C++也很像），因此学起来也比较容易上手。我觉得Java这个语言一个很大的好处就是摒弃了C/C++那些经常会令人头疼的指针。Java使用强大的内存管理，从而避免有安全问题的指针。在Java中有自动垃圾收集。 在Java中有异常处理和类型检查机制。所有这些点是使Java强大的理由。

本阶段的任务之一是使用Java写一个简单的计算器程序，重点就是学Java的GUI编程和事件处理。在这次的计算器中，用到了3个包，分别是java.awt、javax.swing和java.awt.event。首先首先我们需要将界面中要用到的UI组件（按钮、文本框）作为 Calculator 类的成员变量在一开始声明，然后在Calculator的构造函数里设置好这些UI组件的布局、外观等，然后将它们添加到javax.swing.JPanel容器

> JPanel 是一般轻量级容器，可以将其理解为一个盛放其他 UI 组件的“篮子”。 JPanel 位于 `javax.swing` 包中，为面板容器，可以加入到 JFrame 中 ， 它自身是个容器，也可以把其他 component （组件） 加入到 JPanel 中，例如 JButton、JTextArea、JTextField 等

当中，设置好计算器的frame的各种属性，此时编译运行，就可以看到界面了。看到有界面后，编程工作也就变得更加轻松愉快和有动力了。实现了界面之后，这时就要为各个按钮添加事件监听器来相应各种逻辑功能了（注意要在将部件添加到容器内之前注册监听器）。为一个个按钮注册监听器，如

```java
addBtn.addActionListener(new ButtonActionHandler("+"));
```

并且传递一个参数进去，以便让ActionHandler知道是按了哪一个按钮，此时我们要写一个按钮动作处理类ButtonActionHandler来实现ActionListener接口：

```java
private class ButtonActionHandler implements ActionListener {
	public ButtonActionHandler(String operator);
   	@Override
	public void actionPerformed(ActionEvent arg0);
	public String calculateResult(String op);
}
```

重点是实现actionPerformed方法。最后在主函数里new一个Calculator就OK了。

经过这个Java小程序初探Java，体会到Java用起来非常方便，功能强大，以后使用机会应该会很多，学习Java很重要。

### 环境配置

关于环境配置的内容，详见阶段一的自学报告，在此就省略不写了。

------



## 阶段2：基本任务

本阶段要做的是完成GridWorld案例中的各个任务，分别为Part 1~5，根据每个Part的要求来修改代码和回答问题，其中的代码需要通过sonar的检查。

### Part 1~5

在本阶段中，通过完成Part 1~5中的任务，其中包括学习GridWorld的源代码，以及根据要求来修改代码，对Java有了进一步的认识。通过学习使用Sonar来规范自己的代码风格，找出代码中潜在的bug，让自己能写出良好的代码。



### Java面向对象编程总结

在这个阶段里，通过Java的程序设计，我加深了对面向对象编程的认识，在此我主要梳理总结下Java面向对象编程的知识：

#### Java继承 

* **继承的概念**

  继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。

  继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。

  继承表示**IS-A**关系，也称为父子关系。


* **为什么需要继承**

  对于方法覆盖(因此可以实现运行时的多态性)，提高代码可重用性。在Java中，子类可继承父类中的方法，而不需要重新编写相同的方法。但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写(覆盖)。

* **类的继承格式**

  在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来的，一般形式如下：

  ```java
  class 父类 {
      
  }

  class 子类 extends 父类 {
      
  }
  ```

* **继承的特性**

  - 子类拥有父类非private的属性，方法。
  - 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。
  - 子类可以用自己的方式实现父类的方法。
  - Java的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如A类继承B类，B类继承C类，所以按照关系就是C类是B类的父类，B类是A类的父类，这是java继承区别于C++继承的一个特性。
  - 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系）。

* **继承关键字**

  继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 **java.lang** 包中，所以不需要 **import**）祖先类。

  * **extends关键字**

    在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。

  * **implements关键字**

    使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。

    ```java
    public interface A {
        public void eat();
        public void sleep();
    }
     
    public interface B {
        public void show();
    }
     
    public class C implements A, B {
    }
    ```

  * **super 与 this 关键字**

    super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。

    this关键字：指向自己的引用。

  * **final关键字**

    final有最后的，最终的；决定性的；不可更改的意思。final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写：

    * 声明类：

      ```java
      final class 类名 {//类体}
      ```

    * 声明方法：

      ```java
      修饰符(public/private/default/protected) final 返回值类型 方法名(){//方法体}
      ```

    **注：**实例变量也可以被定义为 final，被定义为 final 的变量不能被修改。被声明为 final 类的方法自动地声明为 final，但是实例变量并不是 final

* **构造器**

  子类不能继承父类的构造器（构造方法或者构造函数），但是父类的构造器带有参数的，则必须在子类的构造器中显式地通过super关键字调用父类的构造器并配以适当的参数列表。

  如果父类有无参构造器，则在子类的构造器中用super调用父类构造器不是必须的，如果没有使用super关键字，系统会自动调用父类的无参构造器。


#### Java Override

重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！

重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。

重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。

* **方法的重写规则**
  * 参数列表必须完全与被重写方法的相同；
  * 返回类型必须完全与被重写方法的返回类型相同；
  * 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。
  * 父类的成员方法只能被它的子类重写。
  * 声明为final的方法不能被重写。
  * 声明为static的方法不能被重写，但是能够被再次声明。
  * 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。
  * 子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。
  * 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。
  * 构造方法不能被重写。
  * 如果不能继承一个方法，则不能重写这个方法。



#### Java抽象类

在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。

抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。

由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。

父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。

在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。

* **抽象类**

  在Java语言中使用`abstract class`来定义抽象类。

* **继承抽象类**

  通过一般的方法继承抽象类，方法见Java继承。

* **抽象方法**

  如果想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么可以在父类中声明该方法为抽象方法。

  Abstract关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。

  抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。

  声明抽象方法会造成以下两个结果：

  - 如果一个类包含抽象方法，那么该类必须是抽象类。
  - 任何子类必须重写父类的抽象方法，或者声明自身为抽象类。

  继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。

* **抽象类总结**

  - 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。
  - 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
  - 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。
  - 构造方法，类方法（用static修饰的方法）不能声明为抽象方法。
  - 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。

#### Java接口

接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。

接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。

除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。

接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。

* **接口与类相似点**
  * 一个接口可以有多个方法。
  * 接口文件保存在 .java 结尾的文件中，文件名使用接口名。
  * 接口的字节码文件保存在 .class 结尾的文件中。
  * 接口相应的字节码文件必须在与包名称相匹配的目录结构中。
* **接口与类的区别**
  * 接口不能用于实例化对象。
  * 接口没有构造方法。
  * 接口中所有的方法必须是抽象方法。
  * 接口不能包含成员变量，除了 static 和 final 变量。
  * 接口不是被类继承了，而是要被类实现。
  * 接口支持多继承。
* **接口特性**
  * 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 **public abstract**（只能是 public abstract，其他修饰符都会报错）。
  * 接口中可以含有变量，但是接口中的变量会被隐式的指定为 **public static final** 变量（并且只能是 public，用 private 修饰会报编译错误）。
  * 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。
* **抽象类和接口的区别**
  * 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。
  * 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 **public static final** 类型的。
  * 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。
  *  一个类只能继承一个抽象类，而一个类却可以实现多个接口。

------



## 阶段3：扩展任务

### ImageProcessing

本任务的要求是利用提供的实验软装置，实现一个利用二进制流读取Bitmap图像，并且能够进行简单地处理和保存的软件。

Bitmap的文件结构参考：<http://blog.csdn.net/sjzlxd/article/details/3923907>

这个博客比较详细地说明了Bitmap的文件结构，典型的位图文件格式通常包含下面几个数据块：

- **位图头**： 保存位图文件的总体信息。
- **位图信息**： 保存位图图像的详细信息。
- **调色板**： 保存所用颜色的定义。
- **位图数据**： 保存一个又一个像素的实际图像。

每个数据块详细的文件信息见上述链接，在此不再赘述。

**图像读写：**

* 利用二进制流读取Bitmap图像，具体的步骤思路是：

  1. 用`BufferedInputStream`读取图像，存到`bufferedInputStream`中
  2. 在`bufferedInputStream`中读取位图头和位图信息头，分别存到`byte`数组中
  3. 在`byte`数组中按照Bitmap的文件结构来读取下面步骤需要的信息，比如图像的长、宽、大小等。读取数据时，需要将byte转化成int，此时要注意Windows的数据是倒着念的，这是PC电脑的特色。如果一段数据为50 1A 25 3C，倒着念就是3C 25 1A 50，即0x3C251A50。因此，如果bfSize的数据为50 00 00 00，实际上就成了0x00000050，也就是0x50
  4. 利用行补位的公式：`widthBytes = (biWidth * biBitCount + 31) / 32 * 4` 计算得widthBytes，再吧位图数据按照对应的储存结构读出来存到int数组`pixels`里
  5. 利用数组`pixels`和位图信息创建图像

* 把处理完的图像保存为bmp格式图像

  可以使用Java提供的API完成

**图像处理**

图像处理部分要求提取彩色图像的各个色彩（R, G, B）通道和将彩色的位图转换成灰度图像。

具体的步骤：

1. 新建一个`MyImageFilter`类，继承`java.awt.image.RGBImageFilter`类，构造函数里传入一个`int mask`参数，相当于一个滤镜，其中当mask == 0时是做灰色处理。要注意将父类的`canFilterIndexColorModel`置为`ture`。

2. 重写`filterRGB`方法

   * 提取某个色彩通道，保留该色彩通道，并将每个像素的`rgb`的其他色彩通道置为0即可

   * 转换成灰度图像，在`rgb`中获取r, g, b的值，并利用NTSC推荐的彩色图到灰度图的转换公式：

     I = 0.299 * r + 0.587 * g + 0.114 * b，其中r, g, b分别为红、绿、蓝通道的颜色值。然后将三个色彩通道的颜色值改为这个值即可。这样，原来的彩色图像就变成了灰度图像了。

     ​

### MazeBug

本任务的内容是走无环路迷宫。无环路迷宫在数据结构上表现为一棵树，采用深度优先搜索算法就可以走出迷宫。本实验的目的是学习、理解和应用深度优先搜索算法。本实验要求在改进的Grid World软件装置中实现深度优先搜索算法，从而使虫子走出迷宫。

**深度优先搜索算法的基本步骤：**

此算法对应无环路迷宫的树结构。

1. 先将树的所有节点标记为”未访问”状态。

2. 输出起始节点，将起始节点标记为”已访问”状态。

3. 将起始节点入栈。

4. 当栈非空时重复执行以下步骤：

   a. 取当前栈顶节点。

   b. 如果当前栈顶节点是结束节点（迷宫出口），输出该节点，结束搜索。

   c. 如果当前栈顶节点存在”未访问”状态的邻接节点，则选择一个未访问节点，置为”已访问”状态，并将它入栈，继续步骤a。

   d. 如果当前栈顶节点不存在”未访问”状态的邻接节点，则将栈顶节点出栈，继续步骤a。

**进阶部分**

增加方向的概率估计。五个评估成绩的迷宫都有一定的方向偏向性，如图四就有向上和向左的偏向性。在行走正确路径时，对四个方向的选择次数进行统计，从而控制随机选择时选择某个方向的概率。增加方向的概率估计后能有效地提高走迷宫的效率。



### N-Puzzle

本任务的内容是重排拼图游戏（N-数码问题），通过完成重排拼图游戏，加深对搜索策略的理解和应用：

1. 利用**广度优先搜索**算法求得指定8-数码问题（3*3拼图）的最优解；
2. 利用**启发式搜索**算法求解随机生成的24-数码问题（5*5拼图）。

此任务涉及到两种搜索策略，分别为盲目搜索策略和启发式搜索策略

* **盲目搜索策略**

  用于搜索的方法可分为两大类：盲目搜索和启发式搜索。深度优先搜索(Depth-First-Search)和广度优先搜索(Breadth-First-Search)是常见的盲目搜索方法，它们在搜索节点时都采用固定的排序，没有考虑问题领域可应用的知识，也称为无信息引导的搜索策略。

  此任务涉及到的盲目搜索算法是广度优先搜索（BFS）。

  **BFS算法步骤**

  1. 将起始节点放入一个open列表中。

  2. 如果open列表为空，则搜索失败，问题无解；否则重复以下步骤：

     a. 访问open列表中的第一个节点v，若v为目标节点，则搜索成功，退出。

     b. 从open列表中删除节点v，放入close列表中。

     c. 将所有与v邻接且未曾被访问的节点放入open列表中。

* **启发式搜索**

  * **基本思想**

    与盲目搜索不同，启发式搜索（如A*算法）利用问题拥有的启发信息来引导搜索，动态地确定搜索节点的排序，以达到减少搜索范围，降低问题复杂度的目的。

    在N-数码问题中，每搜索到每一个节点时，通过"估价函数"对该节点进行"评估"，然后优先访问"最优良"节点的邻接节点，能够大大减少求解的时间。

  * **估价函数**

    估价函数f(n)用来估计节点n的重要性，表示为：从起始节点，经过节点n，到达目标节点的代价。f(n)越小，表示节点n越优良，应该优先访问它的邻接节点。可参考的估价方法有：

    1. 所有 放错位的数码 个数
    2. 所有 放错位的数码与其正确位置的距离 之和
    3. 后续节点不正确的数码个数
    4. ......

    可以同时使用多个估价方法，`f(n) = a*f1(n) + b*f2(n) + ...` 通过适当调整权重(`a,b,...`)，能够加快搜索速度。

  * **算法步骤**

    * 将起始节点放入一个列表中。

    * 如果列表为空，则搜索失败，问题无解；否则重复以下步骤：

      a. 访问列表中的第一个节点v，若v为目标节点，则搜索成功，退出。

      b. 从列表中删除节点v。

      c. 利用估价函数，对所有与v邻接且未曾被发现的节点进行估价，按照估价大小（小的在前）插入列表中。

在本任务中，主要是修改启发式搜索中的**估价函数**，经过多次测试、调整，选择了以下估价方法：

* **后续节点不正确**的数码个数
  * 横向后续节点不正确的数码个数
  * 纵向后续节点不正确的数码个数
* 所有 放错位的数码与其正确位置的**欧几里得距离**的平方 之和
* 所有 放错位的数码与其正确位置的**曼哈顿距离** 之和

其中三者的权重分别为8、7、4，最后得到的结果是比较不错的！平均访问节点数仅为2000多个。